[{"title":"iot入门--mips基础","url":"/2025/10/16/iot入门-mips基础/","content":"编译MIPS环境 运行和调试qemu 环境搭建qemu两种模式 qemu-user和qemu-user-static 运行程序小端序：qemu-mipsel ./xxx大端序：qemu-mips ./xxx 调试多架构调试工具 终端运行 再开另一个终端 mips相关知识指令集路由器是一种嵌入式系统，多采用 MIPS 和 ARM 这两种指令架构 MIPS 指令架构属于 RISC (精简指令集) 体系，是一种普遍应用于小型设备的处理器架构，使用 MIPS 指令架构的 Linux 系统便被称为 MIPS Linux，MIPS 架构广泛应用于嵌入式系统领域 RISC 架构的一些典型指令集包括 MIPS, ARM, RISC-V 在路由器中，常用的一种 MIPS 架构就是 MIPS32 在 MIPS 体系结构中有 32 个通用寄存器 REGISTER，其中主要的寄存器如下 REGISTER NAME USAGE $0 zero 存储常量 0 $2-$3 v0−v1 存放函数调用的返回值或表达式 $4-$7 a0−a3 作为函数调用的前四个参数 (arguments) $8-$15 t0−t7 供汇编程序使用的临时寄存器 临时变量 $16-$23 s0−s7 调用子函数时 用于保存原寄存器的值 $24-$25 t8−t9 供汇编程序使用的临时寄存器 补充_t_0−t7 $26-$27 k0−k1 中断&#x2F;异常处理程序使用 保存系统参数 $28 $gp 全局指针 (Global Pointer) $29 $sp 堆栈指针 指向栈顶 (Stack Pointer) $31 $ra 返回地址 (return address) 然后还有 3 个特殊的寄存器，分别是 PC (程序计数器)、HI (乘除结果高位寄存器)、LO (乘除结果低位寄存器) MIPS32 架构的寻址模式有寄存器寻址、立即数寻址、寄存器相对寻址和 PC 相对寻址 在 MIPS 指令集中，需要重点关注的是： l 开头的 LOAD 加载指令和 s 开头的 STORE 存储指令，用于从存储器中读取数据到寄存器，或者将寄存器中的数据保存在存储器中 move 指令用于寄存器之间的值传递 算术运算指令的操作数只能是寄存器，例如 add, sub, mult, div… 它们与 AMD 架构下的算术运算指令比较大的区别是操作数的使用和数量，MIPS 架构的算数运算结果都会存在另外一个寄存器中，而不是去覆盖某一个原本存储某个操作数的寄存器 slt 指令类似于 cmp syscall 的系统调用号存放在 $v0 中 分支跳转指令由 b 开头，如 b target; beq $t0, $t1, target 等 常见的跳转指令有 j target; jr $t3; jal target 函数调用 传参：函数调用时传参：如果函数的参数小于等于四个，那么会使用 $a0 ~ $a3 寄存器来存放参数。如果参数多于四个，那么多于的参数则存放到栈里 调用： MIPS32 架构下的函数有两种类型——叶子函数和非叶子函数。如果一个函数中不会再调用其他任何函数，那么这个函数就是一个叶子函数，其余的函数都是非叶子函数 函数 A 调用函数 B。如果 B 是叶子函数，那么在调用 B 函数时，会将 B 函数的返回地址存入 $ra 寄存器；如果 B 是非叶子函数（B 函数内部调用了一个 C 函数），那么在跳转到 B 函数时，会将其返回地址先存入 $ra 寄存器中，随后在 B 函数内部再将 $ra 寄存器的值存入栈中（位于 fp-0x4 的位置，如下图）。当 B 函数调用 C 函数时，会将其返回地址存入 $ra 寄存器，在返回时执行 jr $ra 指令回到 B 函数。现在假设 B 函数已经执行完毕准备返回到 A 函数，会将原先存入栈里的返回地址读到 $ra 寄存器中，最后执行 jr $ra 指令，回到 A 函数 demo如下 传参 叶子函数 非叶子函数 sp + 0x20保存着旧fp地址sp + 0x24保存着返回地址 栈溢出对于非叶子函数的话，返回地址保存在栈中，通过栈溢出进行劫持返回地址即可。对于叶子函数，利用就比较局限。 例子axb_2019_mips vuln中有栈溢出，因为mips中是没有nx的，通过栈迁移来执行shellcode 从这里可以看出，read的第二个参数a1是由fp控制的。同时又有栈溢出 只要我们控制fp，再返回时通过 lw $fp, 0x38+var_s0($sp) 就能够实现任意地址写。同时劫持ra进行第二次读入 因为我们控制了fp为bss段地址 move $sp, $fp 通过这一条指令即可栈迁移到bss段上。 因为第二次读入时都是通过sp偏移来进行寻址的，我们只需要再bss段中设置好地址就能够劫持ra 读入时从sp + 0x18开始读入，通过栈溢出，将sp + 0x38设置返回地址，在sp + 0x40处布置好shellcode就能够执行shellcode来getshell","date":"2025-10-16","categories":["iot"],"tags":["mips"]},{"title":"高版本largebin_attack","url":"/2025/08/05/高版本largebin-attack/","content":"利用源码 利用原理victim是将要链入largebin的堆块fwd是已经进入large bin中比victim较大的堆块 如果largin bin中仅有一个堆块fwd->fd就指向fwd本身 如果能够控制fwd->bk_nextsize位target_addr，就能向target_addr + 0x20 的位置写入victim的地址 这个0x20是因为c语言中访问结构体对象本质是运用偏移，所以->fd_nextsize相当于+ 0x20 所有largbin attack流程就是： 先使一个堆块进入large bin中，修改其bk_nextsize为target_addr 再使一个比第一个堆块较小的堆块进入large bin即可触发largebin attack largebin attack通常作为io利用的前置，用于修改_io_list_all为堆块地址，再进行相关io的伪造和利用","date":"2025-08-05","tags":["heap"]},{"title":"ret2dl","url":"/2025/05/12/ret2dl/","content":"延迟绑定运作流程 dl_runtime_resolve运作流程理解_dl_runtime_resolve的流程需要了解几个段 1、dynamic段.dynamic段中保存了动态链接器需要的信息，Dynamic Symbol Table（动态链接符号表）、Dynamic String Table（动态链接字符串表）、重定位表等的位置动调看一下具体情况 ELF32_Dyn的结构如下 整个结构体为8字节， 2、Dynamic Symbol Table（动态链接符号表）通常被称为”.dynsym”,readelf -s file可查看，保存了与动态链接相关的符号，”.symtab”中保存了所有符号 3、Dynamic String Table（动态链接字符串表）通常被称为”.dymstr”,再ida中可以找到，记录了符号的名称。因为.dynsym记录了固定长度的内容，不能描述二进制文件的任意字符串，所以需要该表来存储函数的名称。 过程（结合动调来看一下）dl_runtime_resolve(link_map_obj, reloc_index) 它调用了dl_fixup函数 dl_fixup函数又调用了_dl_lookup_symbol_x函数 dl_fixup部分源码如下 首先通过link_map去找到.dynamic的地址，再分别取出.dynstm .dynstr .rel.plt 其中两个入操作为_dl_runtime_resolve的参数，分别是reloc_index,和link_map的地址 link_map源码如下 第三个参数即为.dynamic的地址 readelf -d file查看一下.dynamic内容 .dynstm .dynstr和.rel.plt的偏移分别为9，10，16.结合ELF32_Dyn为8字节，实际的值在后面4节，因此可以得到他们的偏移分别是9*8-4，10*8-4可以对应去取出相应的内容。 rel.plt加上reloc_index就定位了ELF32_Rel指针，即0x804833c + 0 ELF32_Rel源码如下 根据ida中图得知，r_offset即 0x804a00c，是got.plt的地址，最后的解析地址也将会放入这里，r_inf0 &#x3D; 0x107 而将r_info>>8作为dynsym的下标，即0x107>>8&#x3D;1 即右移8位 Elf32_Sym的源码如下 第一个st_name就是.dynstr距离函数名的偏移。 偏移即为20 .dynstr首地址加上0x20就是read的函数名 最后 调用dl_lookup_symbol_x,在动态链接库中搜索。 总结上述过程总结一下 我们的目的是找到函数名称字符串的地址，交给dl_lookup_symbol_x去libc中寻找。 流程便是获得.dynstr中函数名称字符串的流程 首先通过link_map去找到.dynamic段的地址，因为可以以此得到.dynsym .dynstr .rel.plt的地址 .rel.plt地址 加上 dl_runtime_resolve的第二个参数reloc_index可以得到read的Elf32_Rel 接下来通过由ELF32_Rel第二个成员r_info>>8，即可得到.dynsym中的偏移得到read Elf32_Sym Elf32_Sym中的第一个参数st_name存放着函数名称字符串距离.dynstr首地址的偏移，如此便得到了函数名称字符串 漏洞点清楚了上面流程，发现最后dl_lookup_symbol_x函数回去搜索字符串，但是不会检查是否是此时延迟绑定的函数。同时没有检查重定位表的边界，dl_runtime_resolve的第二个参数reloc_index可以很大，超过.rel.plt范围。 因此我们可以伪造第二个参数,使其偏移到我们的可控内存，再按照上面流程，伪造一系列结构，最后让距离 利用x86 只有一个read，没有打印函数 x64x64如果按照x86一样伪造间接控制重定向的各表项，会出现问题。原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址 查看dl_fixup的完整源码分析ret2_dl_runtime_resolve 因此64位下我们需要控制link_map中l->addr 和sym中st_value64位下sym的结构体 其中 Elf64_Word 32 位 Elf64_Section 16 位 Elf64_Addr 64 位 Elf64_Xword 64 位 所以如果将一个函数的got表地址-0x8作为sym的首地址，那么st_value就是got表地址，st_other也不为0 64位link_map的源码 .dynamic对应l_info中的内容 因此我们伪造link_map表时，首先伪造l_info中的3个指针DT_STRTAB指针，DT_SYMTAB指针，DT_JMPREL指针后面控制l_addr的值 然后伪造指向的三个elf64_dyn即可，dynstr只需要指向一个可读的地方，因为并没有用到 64位重定位表项与32位不同 上面几个类型都为64位，因此结构体大小为24字节 另外就是，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0 接下来我们伪造link_map，know_func_ptr为已解析函数的got表地址，offset为system函数与这个函数在libc上的偏移 板子x86 x64 参考链接ret2dl_resolve - 狒猩橙 - 博客园ret2dlresolve超详细教程(x86&x64)-CSDN博客关于ret2_dl_runtime_resolve的学习总结 | ZIKH26’s Blog","date":"2025-05-12","tags":["stack"]},{"title":"前言","url":"/2025/04/29/前言/","content":"​ 重新折腾了一下blog，之前也折腾过一个，但是一段时间就没有管了。写blog主要是想记录自己的生活和学习总结。也是对自己的一个督促。希望有一天自己能够成为独当一面的存在","date":"2025-04-29"},{"title":"about","url":"/about/index.html","content":"a Ctfer,who want to be Developer like football,movie","date":"2025-09-30"},{"title":"categories","url":"/categories/index.html","content":"","date":"2025-09-30"},{"title":"search","url":"/search/index.html","content":"","date":"2025-09-30"},{"title":"tags","url":"/tags/index.html","content":"","date":"2025-09-30"}]