[{"title":"高版本largebin_attack","url":"/2025/08/05/高版本largebin-attack/","content":"利用源码 利用原理victim是将要链入largebin的堆块fwd是已经进入large bin中比victim较大的堆块 如果largin bin中仅有一个堆块fwd->fd就指向fwd本身 如果能够控制fwd->bk_nextsize位target_addr，就能向target_addr + 0x20 的位置写入victim的地址 这个0x20是因为c语言中访问结构体对象本质是运用偏移，所以->fd_nextsize相当于+ 0x20 所有largbin attack流程就是： 先使一个堆块进入large bin中，修改其bk_nextsize为target_addr 再使一个比第一个堆块较小的堆块进入large bin即可触发largebin attack largebin attack通常作为io利用的前置，用于修改_io_list_all为堆块地址，再进行相关io的伪造和利用","date":"2025-08-05","tags":["heap"]},{"title":"ret2dl","url":"/2025/05/12/ret2dl/","content":"延迟绑定运作流程 dl_runtime_resolve运作流程理解_dl_runtime_resolve的流程需要了解几个段 1、dynamic段.dynamic段中保存了动态链接器需要的信息，Dynamic Symbol Table（动态链接符号表）、Dynamic String Table（动态链接字符串表）、重定位表等的位置动调看一下具体情况 ELF32_Dyn的结构如下 整个结构体为8字节， 2、Dynamic Symbol Table（动态链接符号表）通常被称为”.dynsym”,readelf -s file可查看，保存了与动态链接相关的符号，”.symtab”中保存了所有符号 3、Dynamic String Table（动态链接字符串表）通常被称为”.dymstr”,再ida中可以找到，记录了符号的名称。因为.dynsym记录了固定长度的内容，不能描述二进制文件的任意字符串，所以需要该表来存储函数的名称。 过程（结合动调来看一下）dl_runtime_resolve(link_map_obj, reloc_index) 它调用了dl_fixup函数 dl_fixup函数又调用了_dl_lookup_symbol_x函数 dl_fixup部分源码如下 首先通过link_map去找到.dynamic的地址，再分别取出.dynstm .dynstr .rel.plt 其中两个入操作为_dl_runtime_resolve的参数，分别是reloc_index,和link_map的地址 link_map源码如下 第三个参数即为.dynamic的地址 readelf -d file查看一下.dynamic内容 .dynstm .dynstr和.rel.plt的偏移分别为9，10，16.结合ELF32_Dyn为8字节，实际的值在后面4节，因此可以得到他们的偏移分别是9*8-4，10*8-4可以对应去取出相应的内容。 rel.plt加上reloc_index就定位了ELF32_Rel指针，即0x804833c + 0 ELF32_Rel源码如下 根据ida中图得知，r_offset即 0x804a00c，是got.plt的地址，最后的解析地址也将会放入这里，r_inf0 &#x3D; 0x107 而将r_info>>8作为dynsym的下标，即0x107>>8&#x3D;1 即右移8位 Elf32_Sym的源码如下 第一个st_name就是.dynstr距离函数名的偏移。 偏移即为20 .dynstr首地址加上0x20就是read的函数名 最后 调用dl_lookup_symbol_x,在动态链接库中搜索。 总结上述过程总结一下 我们的目的是找到函数名称字符串的地址，交给dl_lookup_symbol_x去libc中寻找。 流程便是获得.dynstr中函数名称字符串的流程 首先通过link_map去找到.dynamic段的地址，因为可以以此得到.dynsym .dynstr .rel.plt的地址 .rel.plt地址 加上 dl_runtime_resolve的第二个参数reloc_index可以得到read的Elf32_Rel 接下来通过由ELF32_Rel第二个成员r_info>>8，即可得到.dynsym中的偏移得到read Elf32_Sym Elf32_Sym中的第一个参数st_name存放着函数名称字符串距离.dynstr首地址的偏移，如此便得到了函数名称字符串 漏洞点清楚了上面流程，发现最后dl_lookup_symbol_x函数回去搜索字符串，但是不会检查是否是此时延迟绑定的函数。同时没有检查重定位表的边界，dl_runtime_resolve的第二个参数reloc_index可以很大，超过.rel.plt范围。 因此我们可以伪造第二个参数,使其偏移到我们的可控内存，再按照上面流程，伪造一系列结构，最后让距离 利用x86 只有一个read，没有打印函数 x64x64如果按照x86一样伪造间接控制重定向的各表项，会出现问题。原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址 查看dl_fixup的完整源码分析ret2_dl_runtime_resolve 因此64位下我们需要控制link_map中l->addr 和sym中st_value64位下sym的结构体 其中 Elf64_Word 32 位 Elf64_Section 16 位 Elf64_Addr 64 位 Elf64_Xword 64 位 所以如果将一个函数的got表地址-0x8作为sym的首地址，那么st_value就是got表地址，st_other也不为0 64位link_map的源码 .dynamic对应l_info中的内容 因此我们伪造link_map表时，首先伪造l_info中的3个指针DT_STRTAB指针，DT_SYMTAB指针，DT_JMPREL指针后面控制l_addr的值 然后伪造指向的三个elf64_dyn即可，dynstr只需要指向一个可读的地方，因为并没有用到 64位重定位表项与32位不同 上面几个类型都为64位，因此结构体大小为24字节 另外就是，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。比如，write 函数 push 的是 0 接下来我们伪造link_map，know_func_ptr为已解析函数的got表地址，offset为system函数与这个函数在libc上的偏移 板子x86 x64 参考链接ret2dl_resolve - 狒猩橙 - 博客园ret2dlresolve超详细教程(x86&x64)-CSDN博客关于ret2_dl_runtime_resolve的学习总结 | ZIKH26’s Blog","date":"2025-05-12","tags":["stack"]},{"title":"前言","url":"/2025/04/29/前言/","content":"​ 重新折腾了一下blog，之前也折腾过一个，但是一段时间就没有管了。写blog主要是想记录自己的生活和学习总结。也是对自己的一个督促。希望有一天自己能够成为独当一面的存在","date":"2025-04-29"}]