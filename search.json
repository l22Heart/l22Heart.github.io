[{"title":"前言","url":"/2025/04/29/%E5%89%8D%E8%A8%80/","content":"​\t重新折腾了一下blog，之前也折腾过一个，但是一段时间就没有管了。写blog主要是想记录自己的生活和学习总结。也是对自己的一个督促。希望有一天自己能够成为独当一面的存在\n"},{"title":"高版本largebin_attack","url":"/2025/08/05/%E9%AB%98%E7%89%88%E6%9C%AClargebin-attack/","content":"利用源码      /* maintain large bins in sorted order */      if (fwd != bck) # 检查large bin是否为空        &#123;          /* Or with inuse bit to speed comparisons */          size |= PREV_INUSE;          /* if smaller than smallest, bypass loop below */          assert (chunk_main_arena (bck-&gt;bk));          if ((unsigned long) (size)&lt; (unsigned long) chunksize_nomask (bck-&gt;bk))            &#123;              fwd = bck;              bck = bck-&gt;bk;              victim-&gt;fd_nextsize = fwd-&gt;fd;              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;          ...      &#125;\n\n利用原理victim是将要链入largebin的堆块fwd是已经进入large bin中比victim较大的堆块\n如果largin bin中仅有一个堆块fwd-&gt;fd就指向fwd本身\n如果能够控制fwd-&gt;bk_nextsize位target_addr，就能向target_addr + 0x20 的位置写入victim的地址\n这个0x20是因为c语言中访问结构体对象本质是运用偏移，所以-&gt;fd_nextsize相当于+ 0x20\n所有largbin attack流程就是：\n先使一个堆块进入large bin中，修改其bk_nextsize为target_addr\n再使一个比第一个堆块较小的堆块进入large bin即可触发largebin attack\nlargebin attack通常作为io利用的前置，用于修改_io_list_all为堆块地址，再进行相关io的伪造和利用\n","tags":["heap"]}]